<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Substratum - Horde Protocol</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', monospace; color: #0f0; }
        
        /* UI OVERLAYS */
        #main-menu { 
            position: absolute; width: 100%; height: 100%; background: #000; 
            z-index: 200; display: flex; flex-direction: column; align-items: center; 
            justify-content: center; text-align: center;
        }
        .menu-btn { 
            padding: 15px 40px; background: none; border: 2px solid #0f0; color: #0f0; 
            font-family: 'Courier New'; cursor: pointer; margin: 10px; transition: 0.3s; font-size: 18px;
        }
        .menu-btn:hover { background: #0f0; color: #000; box-shadow: 0 0 15px #0f0; }
        input { padding: 10px; background: #111; border: 1px solid #0f0; color: #0f0; text-align: center; margin-bottom: 10px; font-family: 'Courier New'; }

        /* HUD Elements */
        #hud { position: absolute; bottom: 20px; left: 20px; z-index: 20; pointer-events: none; display: none; }
        #floor-info { position: absolute; top: 20px; left: 20px; color: #fff; z-index: 20; display: none; }
        .lethal { color: #f00; font-weight: bold; text-shadow: 0 0 8px red; }
        .bar-container { width: 200px; height: 10px; border: 1px solid #333; background: #000; margin: 5px 0; }
        #hp-fill { height: 100%; background: #f00; width: 100%; transition: width 0.2s; }
        #stamina-fill { height: 100%; background: #0f0; width: 100%; }
        #minimap-container { position: absolute; top: 20px; right: 20px; width: 150px; height: 150px; border: 2px solid #0f0; background: rgba(0,0,0,0.8); display: none; }
        #minimap { width: 150px; height: 150px; }
        #event-banner { position: absolute; top: 20%; width: 100%; text-align: center; color: #ff0; font-size: 28px; z-index: 50; display: none; }
        #blocker, #death-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: none; flex-direction: column; align-items: center; justify-content: center; text-align: center; z-index: 100; cursor: pointer; }
    </style>
</head>
<body>

    <div id="main-menu">
        <h1 style="color:#0f0; font-size:60px; letter-spacing:10px; margin-bottom:40px;">SUBSTRATUM</h1>
        <div id="initial-buttons">
            <button onclick="startSolo()" class="menu-btn">SOLO RUN</button>
            <button onclick="showPartyMenu()" class="menu-btn">PARTY</button>
        </div>
        
        <div id="party-menu" style="display:none; flex-direction:column;">
            <button onclick="createParty()" class="menu-btn">CREATE PARTY</button>
            <button onclick="showJoinInput()" class="menu-btn">JOIN PARTY</button>
            <button onclick="backToMain()" class="menu-btn" style="border-color:#555; color:#555;">BACK</button>
            <p id="party-code-display" style="color:#0ff; margin-top:10px;"></p>
        </div>

        <div id="join-input" style="display:none; flex-direction:column;">
            <input type="text" id="join-code" placeholder="ENTER 6-DIGIT CODE">
            <button onclick="joinParty()" class="menu-btn">CONNECT</button>
            <button onclick="backToParty()" class="menu-btn" style="border-color:#555; color:#555;">BACK</button>
        </div>
    </div>

    <div id="event-banner">FLOOR EVENT ACTIVATED</div>
    <div id="floor-info">FLOOR: <span id="floor-num">1</span> | ENTITIES DETECTED: <span id="ent-count-ui">1</span></div>
    <div id="minimap-container"><canvas id="minimap" width="150" height="150"></canvas></div>
    
    <div id="hud">
        HEALTH <div class="bar-container"><div id="hp-fill"></div></div>
        STAMINA <div class="bar-container"><div id="stamina-fill"></div></div>
        ARTIFACTS: <span id="art-count">0</span> / <span id="art-req">5</span>
    </div>

    <div id="blocker"><h1>PAUSED</h1><p>CLICK TO RESUME</p></div>
    <div id="death-screen"><h1>TERMINATED</h1><p id="death-cause"></p><p>CLICK TO RE-INITIALIZE</p></div>

    <script>
        let scene, camera, renderer, controls, socket;
        let prevTime = performance.now();
        let moveF = false, moveB = false, moveL = false, moveR = false, isSprint = false;
        let velocity = new THREE.Vector3(), direction = new THREE.Vector3();
        let hp = 100, stamina = 100, artifacts = 0, currentFloor = 1, gameActive = false;
        let activeEntities = [], walls = [], collectibles = [], exitPortal;
        let otherPlayers = {}; // For Multiplayer Ghosts
        let currentRoom = null;

        const ENTITY_DB = [
            { name: "Lurker", class: "STABLE", speed: 4, color: 0xffaa00 },
            { name: "Twitcher", class: "STABLE", speed: 6, color: 0xff8800 },
            { name: "Heavy Guard", class: "STABLE", speed: 3, color: 0xffcc00 },
            { name: "Glitch Drone", class: "STABLE", speed: 5, color: 0xffff00 },
            { name: "Executioner", class: "LETHAL", speed: 5, color: 0xff0000 },
            { name: "Screamer", class: "LETHAL", speed: 9, color: 0xff0055 }
        ];

        // --- PARTY & SOCKET LOGIC ---
        // Change URL to your Glitch/Server address when ready
        socket = io('http://localhost:3000', { autoConnect: false });

        function startSolo() {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('floor-info').style.display = 'block';
            document.getElementById('minimap-container').style.display = 'block';
            init();
            animate();
            controls.lock();
        }

        function showPartyMenu() {
            document.getElementById('initial-buttons').style.display = 'none';
            document.getElementById('party-menu').style.display = 'flex';
        }

        function backToMain() {
            document.getElementById('initial-buttons').style.display = 'flex';
            document.getElementById('party-menu').style.display = 'none';
        }

        function showJoinInput() {
            document.getElementById('party-menu').style.display = 'none';
            document.getElementById('join-input').style.display = 'flex';
        }

        function createParty() {
            const code = Math.random().toString(36).substring(2, 8).toUpperCase();
            currentRoom = code;
            document.getElementById('party-code-display').innerText = "CODE: " + code;
            socket.connect();
            socket.emit('create-room', code);
            startSolo(); // Start game once code is generated
        }

        function joinParty() {
            const code = document.getElementById('join-code').value.toUpperCase();
            if(code.length > 0) {
                currentRoom = code;
                socket.connect();
                socket.emit('join-room', code);
                startSolo();
            }
        }

        // --- CORE GAME ENGINE ---
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            controls = new THREE.PointerLockControls(camera, document.body);
            document.getElementById('blocker').addEventListener('click', () => controls.lock());
            document.getElementById('death-screen').addEventListener('click', () => location.reload());
            
            controls.addEventListener('lock', () => { gameActive = true; document.getElementById('blocker').style.display='none'; });
            controls.addEventListener('unlock', () => { gameActive = false; if(hp > 0) document.getElementById('blocker').style.display='flex'; });

            window.addEventListener('keydown', (e) => {
                if(e.code==='KeyW') moveF=true; if(e.code==='KeyS') moveB=true;
                if(e.code==='KeyA') moveL=true; if(e.code==='KeyD') moveR=true;
                if(e.shiftKey) isSprint=true;
                if(e.code==='KeyE') checkInteract();
            });
            window.addEventListener('keyup', (e) => {
                if(e.code==='KeyW') moveF=false; if(e.code==='KeyS') moveB=false;
                if(e.code==='KeyA') moveL=false; if(e.code==='KeyD') moveR=false;
                if(!e.shiftKey) isSprint=false;
            });

            // Listen for other players
            socket.on('player-update', (data) => {
                if(!otherPlayers[data.id]) {
                    const ghostGeo = new THREE.BoxGeometry(1, 2, 1);
                    const ghostMat = new THREE.MeshBasicMaterial({color: 0x00aaff, wireframe: true});
                    const ghost = new THREE.Mesh(ghostGeo, ghostMat);
                    scene.add(ghost);
                    otherPlayers[data.id] = ghost;
                }
                otherPlayers[data.id].position.copy(data.pos);
            });

            generateFloor();
        }

        function generateFloor() {
            walls.forEach(w => scene.remove(w));
            collectibles.forEach(c => scene.remove(c));
            activeEntities.forEach(e => scene.remove(e.mesh));
            if(exitPortal) scene.remove(exitPortal);

            walls = []; collectibles = []; activeEntities = []; artifacts = 0; hp = 100;
            let artReq = 4 + currentFloor;
            document.getElementById('art-req').innerText = artReq;
            document.getElementById('floor-num').innerText = currentFloor;
            document.getElementById('art-count').innerText = "0";
            camera.position.set(0, 1.6, 0);

            // Walls & Environment
            for(let i=0; i<60; i++) {
                const wall = new THREE.Mesh(new THREE.BoxGeometry(4, 10, 4), new THREE.MeshBasicMaterial({color: 0x111111}));
                let rx = (Math.random()-0.5)*120; let rz = (Math.random()-0.5)*120;
                if(Math.abs(rx) < 15 && Math.abs(rz) < 15) continue;
                wall.position.set(rx, 5, rz); scene.add(wall); walls.push(wall);
            }

            // Artifacts
            for(let i=0; i<artReq; i++) {
                const art = new THREE.Mesh(new THREE.TorusKnotGeometry(0.4, 0.1, 32, 8), new THREE.MeshBasicMaterial({color: 0x00ffff}));
                art.position.set((Math.random()-0.5)*100, 1.2, (Math.random()-0.5)*100);
                art.userData = {type: "artifact"}; scene.add(art); collectibles.push(art);
            }

            // Entity Scaling (Every 3 floors)
            let entityLimit = Math.floor((currentFloor - 1) / 3) + 1;
            document.getElementById('ent-count-ui').innerText = entityLimit;
            for(let i=0; i < entityLimit; i++) {
                const data = ENTITY_DB[Math.floor(Math.random()*ENTITY_DB.length)];
                const geo = data.class === "LETHAL" ? new THREE.IcosahedronGeometry(1.5, 0) : new THREE.BoxGeometry(1.2, 2.5, 1.2);
                const mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({color: data.color, wireframe: data.class === "LETHAL"}));
                mesh.position.set((Math.random()-0.5)*100, 1.25, (Math.random()-0.5)*100);
                activeEntities.push({ mesh, data }); scene.add(mesh);
            }

            exitPortal = new THREE.Mesh(new THREE.BoxGeometry(6, 12, 1), new THREE.MeshBasicMaterial({color: 0xffffff, transparent:true, opacity:0}));
            exitPortal.position.set(0, 5, -55); scene.add(exitPortal);
        }

        function checkInteract() {
            collectibles.forEach((c, i) => {
                if(camera.position.distanceTo(c.position) < 4) {
                    artifacts++;
                    document.getElementById('art-count').innerText = artifacts;
                    scene.remove(c); collectibles.splice(i, 1);
                }
            });
            if(artifacts >= (4 + currentFloor)) {
                exitPortal.material.opacity = 0.5;
                if(camera.position.distanceTo(exitPortal.position) < 5) { currentFloor++; generateFloor(); }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            if(!gameActive) return;

            const time = performance.now();
            const delta = Math.min((time - prevTime) / 1000, 0.1);

            let speed = (isSprint && stamina > 0 ? 140 : 85);
            if(isSprint && stamina > 0 && (moveF||moveB||moveL||moveR)) stamina -= 35 * delta;
            else stamina = Math.min(100, stamina + 20 * delta);

            velocity.x -= velocity.x * 10.0 * delta; velocity.z -= velocity.z * 10.0 * delta;
            direction.z = Number(moveF) - Number(moveB); direction.x = Number(moveR) - Number(moveL);
            direction.normalize();
            if (moveF || moveB) velocity.z -= direction.z * speed * delta;
            if (moveL || moveR) velocity.x -= direction.x * speed * delta;
            controls.moveRight(-velocity.x * delta); controls.moveForward(-velocity.z * delta);

            // SEND POSITION TO SERVER
            if(socket.connected && currentRoom) {
                socket.emit('move', { room: currentRoom, pos: camera.position });
            }

            // ENTITY AI
            activeEntities.forEach(entObj => {
                const ent = entObj.mesh;
                const chase = new THREE.Vector3().subVectors(camera.position, ent.position).normalize();
                ent.position.add(chase.multiplyScalar(entObj.data.speed * delta));
                ent.lookAt(camera.position.x, 1.25, camera.position.z);
                if(ent.position.distanceTo(camera.position) < 2.5) {
                    hp -= entObj.data.class === "LETHAL" ? 100 : 45 * delta;
                    if(hp <= 0) {
                        gameActive=false; 
                        document.getElementById('death-screen').style.display='flex'; 
                        document.getElementById('death-cause').innerText="KILLED BY " + entObj.data.name; 
                    }
                }
            });

            // HUD & MINIMAP
            document.getElementById('hp-fill').style.width = hp + '%';
            document.getElementById('stamina-fill').style.width = stamina + '%';
            const ctx = document.getElementById('minimap').getContext('2d');
            ctx.fillStyle = '#000'; ctx.fillRect(0,0,150,150);
            const scale = 1.5;
            walls.forEach(w => { ctx.fillStyle = '#222'; ctx.fillRect((w.position.x - camera.position.x)*scale+75, (w.position.z - camera.position.z)*scale+75, 4, 4); });
            collectibles.forEach(c => { ctx.fillStyle = '#0ff'; ctx.fillRect((c.position.x - camera.position.x)*scale+75, (c.position.z - camera.position.z)*scale+75, 5, 5); });
            activeEntities.forEach(e => { ctx.fillStyle = 'red'; ctx.fillRect((e.mesh.position.x - camera.position.x)*scale+75, (e.mesh.position.z - camera.position.z)*scale+75, 6, 6); });
            ctx.fillStyle = '#0f0'; ctx.beginPath(); ctx.arc(75, 75, 3, 0, Math.PI*2); ctx.fill();

            prevTime = time;
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>